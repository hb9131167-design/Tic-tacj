<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candy Blaster Deluxe</title>
    <style>
        :root {
            --board-size: 8;
            --cell-size: min(10.5vw, 55px);
            --board-bg: #f8c3d8; /* Light Pink */
            --cell-bg: rgba(255, 255, 255, 0.4);
            --font-family: 'Arial', 'Helvetica Neue', sans-serif;
            --candy-pink: #ff69b4;
            --gold: #FFD700;
            --blue: #89cff0;
            --dark-blue: #2c3e50;
            --coin-color: #f7b731;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, #a8d0e6, #f8c3d8, #f7d8a8);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            color: #4a4a4a;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }

        .hidden { display: none !important; }

        /* --- Splash Screen --- */
        #splash-screen {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: var(--dark-blue); color: white; position: absolute; inset: 0; z-index: 200;
            animation: fadeOut 1s ease 3s forwards;
        }
        #splash-screen h1 { font-size: 4rem; animation: bounceIn 1s ease; }
        #splash-screen p { font-size: 1.5rem; animation: fadeIn 1s ease 1s forwards; opacity: 0; }

        /* --- Main Menu --- */
        #main-menu-container {
            position: relative; text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px; border-radius: 25px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.25);
            animation: popIn 0.5s ease-out;
            overflow: hidden;
        }
        #main-menu h1 {
            font-size: 3.8rem; margin-bottom: 20px;
            color: var(--candy-pink); text-shadow: 3px 3px var(--blue);
            animation: pulse 2s infinite;
        }
        #player-coins-menu {
            font-size: 1.5rem; font-weight: bold; margin-bottom: 20px;
            color: var(--coin-color); text-shadow: 1px 1px #000;
        }
        .menu-button {
            display: block; width: 220px; padding: 15px; margin: 15px auto;
            font-size: 1.3rem; font-weight: bold; color: white;
            background: linear-gradient(45deg, var(--candy-pink), var(--blue));
            border: none; border-radius: 12px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative; z-index: 10;
        }
        .menu-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 105, 180, 0.6);
        }
        .menu-button:disabled { background: #9E9E9E; cursor: not-allowed; transform: none; box-shadow: none;}

        #floating-candies { position: absolute; inset: 0; z-index: 1; pointer-events: none; }
        .floating-candy {
            position: absolute; font-size: 2rem; opacity: 0;
            animation: floatUp 10s infinite linear;
        }
        @keyframes floatUp {
            0% { transform: translateY(100%); opacity: 0; }
            10%, 90% { opacity: 0.7; }
            100% { transform: translateY(-100%); opacity: 0; }
        }

        /* --- Level Select --- */
        #level-select-screen {
            background: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); max-height: 90vh; overflow-y: auto;
        }
        #level-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; }
        .level-button {
            width: 65px; height: 65px; background: var(--blue); color: white; border: none;
            border-radius: 10px; font-size: 1.5rem; cursor: pointer;
            display: flex; justify-content: center; align-items: center; flex-direction: column; position: relative;
            transition: transform 0.2s;
        }
        .level-button:not(:disabled):hover { transform: scale(1.1); }
        .level-button .stars { font-size: 0.7rem; color: var(--gold); }
        .level-button:disabled { background: #9E9E9E; cursor: not-allowed; }
        .back-button { margin-top: 20px; }

        /* --- Game Container --- */
        #game-container { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #game-hud {
            display: flex; justify-content: space-between; align-items: center;
            width: calc(var(--cell-size) * var(--board-size) + 40px);
            background: rgba(255, 255, 255, 0.7); padding: 10px 20px;
            border-radius: 10px; font-size: 1.2rem; font-weight: bold;
        }
        #hud-left { display: flex; align-items: center; gap: 15px; }
        #mute-button { background: none; border: none; font-size: 1.5rem; cursor: pointer;}
        #objective-display { text-align: center; flex-grow: 1; }
        #moves-display.moves-warning { animation: pulse-red 1s infinite; }
        @keyframes pulse-red {
            0%, 100% { transform: scale(1); color: #4a4a4a; }
            50% { transform: scale(1.1); color: #F44336; }
        }
        #player-coins-game { font-weight: bold; color: var(--coin-color); text-shadow: 1px 1px #000; }

        #game-board-area { position: relative; }
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-size), var(--cell-size));
            grid-template-rows: repeat(var(--board-size), var(--cell-size));
            background: var(--board-bg); padding: 10px; border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3); position: relative;
            touch-action: none;
        }
        #ingredient-exits {
            position: absolute; bottom: -5px; width: 100%; display: flex;
            justify-content: space-around; pointer-events: none;
            padding: 0 10px; box-sizing: border-box;
        }
        .exit-point { 
            width: var(--cell-size); text-align: center;
            font-size: calc(var(--cell-size) * 0.5); color: #4CAF50; opacity: 0; 
        }
        .exit-point.active { opacity: 1; }

        .cell {
            background: var(--cell-bg);
            border: 1px solid rgba(255, 255, 255, 0.6);
            display: flex; justify-content: center; align-items: center;
            font-size: calc(var(--cell-size) * 0.7);
            cursor: pointer; transition: transform 0.2s, background-color 0.2s;
            position: relative;
        }
        .cell.selected { animation: selected-pulse 1.2s infinite ease-in-out; background: rgba(255, 255, 0, 0.5); }
        @keyframes selected-pulse {
            0%, 100% { transform: scale(1.05); } 50% { transform: scale(1.15); }
        }
        .powerup-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' style='font-size: 24px;'><text y='24'>🔨</text></svg>") 16 16, pointer; }
        
        /* Blockers & Ingredients */
        .jelly-1 { background: rgba(147, 112, 219, 0.4); }
        .jelly-2 { background: rgba(147, 112, 219, 0.7); border: 2px solid rgba(147, 112, 219, 1); }
        .stone-1 { background: rgba(140, 140, 140, 0.4); }
        .stone-2 { background: rgba(140, 140, 140, 0.7); border: 2px solid rgba(100, 100, 100, 1); }
        .ingredient { font-size: calc(var(--cell-size) * 0.8); z-index: 15 !important; animation-duration: 0.8s; }

        .candy {
            animation: fallIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            position: absolute; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            transition: transform 0.3s ease; z-index: 10;
            pointer-events: none;
        }
        
        /* Special Candy Visuals */
        .candy-line-h::after, .candy-line-v::after { content: ''; position: absolute; background: white; opacity: 0.8; border-radius: 5px; box-shadow: 0 0 5px white; }
        .candy-line-h::after { width: 80%; height: 10%; left: 10%; top: 45%; }
        .candy-line-v::after { width: 10%; height: 80%; left: 45%; top: 10%; }
        .candy-bomb { animation: pulse 1s infinite; }
        .candy-bomb::before { content: '💥'; position: absolute; font-size: 0.5em; opacity: 0.7; animation: spin 2s infinite linear; }
        .candy-color { background: radial-gradient(circle, #ff00ff, #00ffff, #ffff00, #ff00ff); background-size: 400% 400%; -webkit-background-clip: text; background-clip: text; color: transparent; animation: color-cycle 3s infinite linear, pulse 1.5s infinite; font-size: 1.2em; font-weight: bold; }
        @keyframes color-cycle { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }

        /* Power-ups Bar */
        #powerups-bar {
            display: flex; gap: 15px; background: rgba(255, 255, 255, 0.7);
            padding: 10px 20px; border-radius: 10px;
        }
        .powerup-button {
            background: var(--blue); color: white; border: 3px solid white;
            border-radius: 10px; width: 60px; height: 60px;
            font-size: 1.8rem; cursor: pointer; position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: transform 0.2s, background-color 0.2s;
        }
        .powerup-button:hover { transform: translateY(-3px); }
        .powerup-button.active { background-color: var(--candy-pink); border-color: var(--gold); transform: scale(1.1); }
        .powerup-count {
            position: absolute; bottom: -5px; right: -5px; background: var(--candy-pink);
            color: white; border-radius: 50%; width: 22px; height: 22px;
            font-size: 0.9rem; font-weight: bold; line-height: 22px; text-align: center;
            border: 2px solid white;
        }

        /* --- Popups --- */
        .popup {
            position: fixed; inset: 0; background: rgba(0,0,0,0.6);
            display: flex; justify-content: center; align-items: center; z-index: 50;
        }
        .popup-content {
            background: white; padding: 30px; border-radius: 15px; text-align: center;
            animation: popIn 0.3s ease; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            min-width: 300px; max-width: 90%;
        }
        .popup-content h2 { margin-top: 0; font-size: 2rem; color: var(--candy-pink); }
        .popup-content p { font-size: 1.2rem; }
        .popup-content .stars { font-size: 2.5rem; color: var(--gold); }
        .star-animated { transform: scale(0); animation: star-pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
        @keyframes star-pop-in { to { transform: scale(1); } }

        /* Shop Popup */
        #shop-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0; }
        .shop-item { border: 2px solid var(--blue); border-radius: 10px; padding: 15px; }
        .shop-item .icon { font-size: 2.5rem; }
        .shop-item .price { font-weight: bold; color: var(--coin-color); margin: 5px 0; }
        .shop-item button { width: 100%; margin: 5px 0 0; padding: 8px;}

        /* --- Animations --- */
        @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
        @keyframes fadeIn { to { opacity: 1; } }
        @keyframes bounceIn {
            0%, 20%, 40%, 60%, 80%, 100% { animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1); }
            0% { opacity: 0; transform: scale3d(.3, .3, .3); } 20% { transform: scale3d(1.1, 1.1, 1.1); }
            40% { transform: scale3d(.9, .9, .9); } 60% { opacity: 1; transform: scale3d(1.03, 1.03, 1.03); }
            80% { transform: scale3d(.97, .97, .97); } 100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes fallIn { from { transform: translateY(-100px); opacity: 0; } 60% { transform: translateY(5px); opacity: 1; } 80% { transform: translateY(-5px); } to { transform: translateY(0); opacity: 1; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .crush-animation { animation: crush 0.5s ease-out forwards; z-index: 11; }
        @keyframes crush { 0% { transform: scale(1) rotate(0deg); opacity: 1; } 50% { transform: scale(1.6) rotate(180deg); filter: brightness(2); } 100% { transform: scale(0) rotate(360deg); opacity: 0; } }
        .line-zap-h, .line-zap-v { position: absolute; background: white; box-shadow: 0 0 15px 5px white; border-radius: 10px; animation: zap-out 0.4s ease-out forwards; z-index: 20; }
        .line-zap-h { left: 0; width: 100%; height: 20%; top: 40%; }
        .line-zap-v { top: 0; height: 100%; width: 20%; left: 40%; }
        @keyframes zap-out { from { transform: scale(0); } to { transform: scale(1); opacity: 0; } }
        .bomb-explosion { position: absolute; width: calc(var(--cell-size) * 3); height: calc(var(--cell-size) * 3); background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,223,186,0.8) 50%, rgba(255,105,180,0) 70%); border-radius: 50%; transform: translate(-50%, -50%) scale(0); animation: bomb-blast 0.4s ease-out forwards; z-index: 20; }
        @keyframes bomb-blast { from { transform: translate(-50%,-50%) scale(0); opacity: 1; } to { transform: translate(-50%,-50%) scale(1.2); opacity: 0; } }
        
        .collection-item { display: inline-flex; align-items: center; margin: 0 5px; transition: transform 0.3s; }
        .collection-item.objective-complete-animation { animation: flash-green 0.8s; }
        @keyframes flash-green { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); color: #4CAF50; } }
        .collection-icon { font-size: 1.2rem; margin-right: 3px; }

        .combo-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: bold; color: white; text-shadow: 3px 3px 5px rgba(0,0,0,0.5); pointer-events: none; z-index: 100; animation: pop-and-fade 1.5s ease-out forwards; }
        @keyframes pop-and-fade { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 80% { transform: translate(-50%, -60%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -70%) scale(0.8); opacity: 0; } }
    </style>
</head>
<body>

    <!-- Splash Screen -->
    <div id="splash-screen">
        <h1>🍬</h1>
        <p>BG Studios Presents</p>
    </div>

    <!-- Main Menu -->
    <div id="main-menu-container" class="hidden">
        <div id="floating-candies"></div>
        <div id="main-menu">
            <h1>Candy Blaster Deluxe</h1>
            <div id="player-coins-menu">💰 0</div>
            <button id="play-button" class="menu-button">Play</button>
            <button id="levels-button" class="menu-button">Levels</button>
            <button id="shop-button" class="menu-button">Shop</button>
            <button id="how-to-play-button" class="menu-button">How to Play</button>
        </div>
    </div>
    
    <!-- Level Select Screen -->
    <div id="level-select-screen" class="hidden">
        <h2>Select Level</h2>
        <div id="level-grid"></div>
        <button id="back-to-menu-button" class="menu-button back-button">Back to Menu</button>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="hidden">
        <div id="game-hud">
             <div id="hud-left">
                <div id="level-display">Level: 1</div>
                <button id="mute-button">🔊</button>
            </div>
            <div id="objective-display">Score: 0</div>
            <div id="moves-and-coins-right">
                <div id="moves-display">Moves: 20</div>
                <div id="player-coins-game">💰 0</div>
            </div>
        </div>
        <div id="game-board-area">
            <div id="game-board"></div>
            <div id="ingredient-exits"></div>
        </div>
        <div id="powerups-bar">
            <button class="powerup-button" id="powerup-hammer" data-powerup="hammer">🔨<span class="powerup-count" id="count-hammer">0</span></button>
            <button class="powerup-button" id="powerup-bomb" data-powerup="bomb">💣<span class="powerup-count" id="count-bomb">0</span></button>
            <button class="powerup-button" id="powerup-shuffle" data-powerup="shuffle">🔄<span class="powerup-count" id="count-shuffle">0</span></button>
        </div>
        <button id="quit-game-button" class="menu-button back-button">Quit</button>
    </div>
    
    <!-- Popups -->
    <div id="goal-popup" class="popup hidden">
        <div class="popup-content">
            <h2 id="goal-level">Level 1</h2>
            <p id="goal-objective">Target: 5000 points</p>
            <button id="start-level-button" class="menu-button">Start!</button>
        </div>
    </div>
    
    <div id="extra-moves-popup" class="popup hidden">
        <div class="popup-content">
            <h2 style="color: #F44336;">Out of Moves!</h2>
            <p>Get 5 extra moves to continue.</p>
            <p>Cost: <span id="extra-moves-cost" style="font-weight:bold; color: var(--coin-color)">100 💰</span></p>
            <button id="buy-moves-button" class="menu-button">Buy Moves</button>
            <button id="give-up-button" class="menu-button" style="background: #9E9E9E;">Give Up</button>
        </div>
    </div>
    
    <div id="game-over-popup" class="popup hidden">
        <div class="popup-content">
            <h2 style="color: #F44336;">Level Failed!</h2>
            <p id="final-score-lose"></p>
            <button id="retry-button" class="menu-button">Retry</button>
            <button id="game-over-menu-button" class="menu-button">Main Menu</button>
        </div>
    </div>

    <div id="level-complete-popup" class="popup hidden">
        <div class="popup-content">
            <h2>Level Complete!</h2>
            <p id="final-score-win"></p>
            <p id="coins-earned" style="font-weight:bold; color: var(--coin-color); font-size:1.4rem;"></p>
            <div id="star-rating" class="stars"></div>
            <button id="next-level-button" class="menu-button">Next Level</button>
            <button id="level-complete-menu-button" class="menu-button">Main Menu</button>
        </div>
    </div>
    
    <div id="how-to-play-popup" class="popup hidden">
        <div class="popup-content" style="text-align: left; max-width: 450px;">
            <h2>How to Play</h2>
            <p>- <strong>Swipe</strong> candies to match 3 or more.</p>
            <p>- <strong>Match 4:</strong> Creates a Line Blaster.</p>
            <p>- <strong>Match 5 (T/L):</strong> Creates a Bomb.</p>
            <p>- <strong>Match 5 (Line):</strong> Creates a Rainbow Gem.</p>
            <p>- <strong>Jelly Levels:</strong> Clear jelly by matching on top.</p>
            <p>- <strong>Stone Levels:</strong> Break stones by matching next to them.</p>
            <p>- <strong>Ingredient Levels:</strong> Drop ingredients 🍒 to the bottom.</p>
            <button id="close-how-to-play-button" class="menu-button" style="margin: 20px auto 0;">Got it!</button>
        </div>
    </div>

    <div id="daily-reward-popup" class="popup hidden">
        <div class="popup-content">
            <h2>Daily Reward!</h2>
            <p>Welcome back! Here is your reward:</p>
            <p id="daily-reward-text" style="font-size: 1.5rem; font-weight: bold;"></p>
            <button id="claim-reward-button" class="menu-button">Claim!</button>
        </div>
    </div>

    <div id="shop-popup" class="popup hidden">
        <div class="popup-content">
            <h2>Shop</h2>
            <p>Buy power-ups with your coins!</p>
            <div id="shop-grid">
                <div class="shop-item">
                    <div class="icon">🔨</div>
                    <div>+3 Hammers</div>
                    <div class="price">150 💰</div>
                    <button class="menu-button buy-powerup-button" data-item="hammer" data-amount="3" data-price="150">Buy</button>
                </div>
                <div class="shop-item">
                    <div class="icon">💣</div>
                    <div>+3 Bombs</div>
                    <div class="price">200 💰</div>
                    <button class="menu-button buy-powerup-button" data-item="bomb" data-amount="3" data-price="200">Buy</button>
                </div>
                <div class="shop-item">
                    <div class="icon">🔄</div>
                    <div>+3 Shuffles</div>
                    <div class="price">100 💰</div>
                    <button class="menu-button buy-powerup-button" data-item="shuffle" data-amount="3" data-price="100">Buy</button>
                </div>
            </div>
            <button id="close-shop-button" class="menu-button">Close</button>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- 1. Constants & State Variables ---
        const BOARD_SIZE = 8;
        const CANDIES = ['🍡', '🍬', '🍫', '🍭', '🍩', '🍪'];
        const ALL_CANDIES = ['🍡', '🍨', '🍧', '🍫', '🍬', '🧁', '🍯', '🥞', '🎂', '🍩', '🍪', '🧇', '🍭', '🍥'];
        const INGREDIENT = '🍒';
        const RAINBOW_GEM = '💎';
        const TOTAL_LEVELS = 500;
        const EXTRA_MOVES_COST = 100;

        let board = [];
        let isProcessing = false;
        let currentLevel = 1;
        let movesLeft = 0;
        let score = 0;
        let levelObjective = {};
        
        let playerProgress = {
            unlockedLevel: 1,
            levelStars: {},
            coins: 100,
            powerUps: { hammer: 3, bomb: 3, shuffle: 3 },
            lastLogin: null
        };
        
        let activePowerUp = null;
        let dragStartCell = null;

        // --- SOUND MANAGER ---
        const soundManager = {
            isMuted: false,
            sounds: {
                swap: new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_2b63bde317.mp3'),
                match: new Audio('https://cdn.pixabay.com/audio/2022/03/10/audio_c3b092d349.mp3'),
                specialCreate: new Audio('https://cdn.pixabay.com/audio/2021/08/04/audio_51a708a39d.mp3'),
                bomb: new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_e67507c570.mp3'),
                line: new Audio('https://cdn.pixabay.com/audio/2022/01/18/audio_8db1f89b93.mp3'),
                win: new Audio('https://cdn.pixabay.com/audio/2022/01/18/audio_29b6894ab6.mp3'),
                lose: new Audio('https://cdn.pixabay.com/audio/2022/01/28/audio_27714811a0.mp3'),
                click: new Audio('https://cdn.pixabay.com/audio/2022/03/10/audio_c642f5c1b8.mp3')
            },
            play: function(soundName) {
                if (!this.isMuted && this.sounds[soundName]) {
                    this.sounds[soundName].currentTime = 0;
                    this.sounds[soundName].play().catch(e => {});
                }
            },
            toggleMute: function(buttonElement) {
                this.isMuted = !this.isMuted;
                buttonElement.textContent = this.isMuted ? '🔇' : '🔊';
            }
        };

        // --- 2. Level Data & Generation ---
        let levels = [];

        function generateLevel(levelNum) {
            if (levelNum <= 10) { // Pre-defined starter levels
                const predefined = [
                    { level: 1, type: 'score', moves: 20, target: 1000 },
                    { level: 2, type: 'score', moves: 18, target: 1500 },
                    { level: 3, type: 'jelly', moves: 25, jellyGoal: 16, layout: ['00000000','00111100','00111100','00111100','00111100','00111100','00000000','00000000'] },
                    { level: 4, type: 'collection', moves: 25, collectGoal: { '🍡': 15, '🍬': 10 } },
                    { level: 5, type: 'score', moves: 20, target: 2500 },
                    { level: 6, type: 'stone', moves: 30, stoneGoal: 12, layout: ['00000000','00111100','01111110','01100110','01100110','01111110','00111100','00000000']},
                    { level: 7, type: 'jelly', moves: 30, jellyGoal: 32, layout: ['11000011','11000011','00111100','00111100','00111100','00111100','11000011','11000011']},
                    { level: 8, type: 'collection', moves: 28, collectGoal: { '🍫': 20, '🍩': 20 } },
                    { level: 9, type: 'ingredient', moves: 25, ingredientGoal: 2, exitCols: [3, 4] },
                    { level: 10, type: 'score', moves: 15, target: 4000 }
                ];
                return predefined[levelNum - 1];
            }

            const level = { level: levelNum };
            const difficulty = Math.log10(levelNum) * Math.sqrt(levelNum);
            const typeRand = Math.random();

            if (typeRand < 0.25) { // Score
                level.type = 'score';
                level.moves = Math.max(15, 35 - Math.floor(difficulty / 2));
                level.target = 1000 + Math.floor(difficulty * 150);
            } else if (typeRand < 0.5) { // Jelly/Stone
                const isJelly = Math.random() < 0.6;
                level.type = isJelly ? 'jelly' : 'stone';
                level.moves = Math.max(20, 40 - Math.floor(difficulty / 1.5));
                let layout = Array(8).fill('').map(() => Array(8).fill('0'));
                let target = 0;
                const patternComplexity = Math.min(0.8, 0.2 + difficulty / 50);
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (Math.random() < patternComplexity) {
                            layout[r][c] = '1';
                            target++;
                        }
                    }
                }
                if (target === 0) { layout[3][3] = '1'; layout[4][4] = '1'; target = 2; }
                level.layout = layout.map(row => row.join(''));
                if (isJelly) level.jellyGoal = target;
                else level.stoneGoal = target;

            } else if (typeRand < 0.8) { // Collection
                level.type = 'collection';
                level.moves = Math.max(20, 38 - Math.floor(difficulty / 2));
                level.collectGoal = {};
                const numToCollect = Math.min(4, 2 + Math.floor(difficulty / 15));
                const shuffledCandies = [...CANDIES].sort(() => 0.5 - Math.random());
                for (let i = 0; i < numToCollect; i++) {
                    level.collectGoal[shuffledCandies[i]] = 10 + Math.floor(difficulty);
                }
            } else { // Ingredient
                level.type = 'ingredient';
                level.moves = Math.max(25, 45 - Math.floor(difficulty));
                level.ingredientGoal = Math.min(4, 1 + Math.floor(difficulty / 10));
                let exits = new Set();
                while(exits.size < 2 + Math.floor(difficulty / 20)) {
                    exits.add(Math.floor(Math.random() * BOARD_SIZE));
                }
                level.exitCols = [...exits];
            }
            return level;
        }

        function populateLevels() {
            for (let i = 1; i <= TOTAL_LEVELS; i++) {
                levels.push(generateLevel(i));
            }
        }

        // --- 3. DOM Elements ---
        const get = (id) => document.getElementById(id);
        const splashScreen = get('splash-screen'), mainMenuContainer = get('main-menu-container'), gameContainer = get('game-container'),
              levelSelectScreen = get('level-select-screen'), playButton = get('play-button'), levelsButton = get('levels-button'),
              shopButton = get('shop-button'), howToPlayButton = get('how-to-play-button'), quitGameButton = get('quit-game-button'),
              goalPopup = get('goal-popup'), extraMovesPopup = get('extra-moves-popup'), gameOverPopup = get('game-over-popup'),
              levelCompletePopup = get('level-complete-popup'), howToPlayPopup = get('how-to-play-popup'),
              dailyRewardPopup = get('daily-reward-popup'), shopPopup = get('shop-popup'), gameBoard = get('game-board');

        // --- 4. Game Initialization & UI Flow ---
        function init() {
            loadPlayerProgress();
            populateLevels();
            
            setTimeout(() => {
                splashScreen.classList.add('hidden');
                mainMenuContainer.classList.remove('hidden');
                createFloatingCandies();
                checkDailyReward();
            }, 3500);

            document.querySelectorAll('.menu-button').forEach(button => {
                button.addEventListener('click', () => soundManager.play('click'));
            });

            playButton.addEventListener('click', () => showLevelGoal(playerProgress.unlockedLevel));
            levelsButton.addEventListener('click', showLevelSelect);
            howToPlayButton.addEventListener('click', () => howToPlayPopup.classList.remove('hidden'));
            get('close-how-to-play-button').addEventListener('click', () => howToPlayPopup.classList.add('hidden'));
            shopButton.addEventListener('click', showShop);
            get('close-shop-button').addEventListener('click', () => shopPopup.classList.add('hidden'));

            get('back-to-menu-button').addEventListener('click', showMainMenu);
            quitGameButton.addEventListener('click', () => { gameContainer.classList.add('hidden'); showMainMenu(); });
            get('start-level-button').addEventListener('click', () => { goalPopup.classList.add('hidden'); startGame(currentLevel); });
            get('retry-button').addEventListener('click', () => { gameOverPopup.classList.add('hidden'); showLevelGoal(currentLevel); });
            get('next-level-button').addEventListener('click', () => {
                levelCompletePopup.classList.add('hidden');
                if (currentLevel < levels.length) { currentLevel++; showLevelGoal(currentLevel); } 
                else { alert("Congratulations! You've completed all levels!"); showMainMenu(); }
            });
            get('game-over-menu-button').addEventListener('click', () => { gameOverPopup.classList.add('hidden'); showMainMenu(); });
            get('level-complete-menu-button').addEventListener('click', () => { levelCompletePopup.classList.add('hidden'); showMainMenu(); });
            
            get('buy-moves-button').addEventListener('click', buyExtraMoves);
            get('give-up-button').addEventListener('click', () => {
                extraMovesPopup.classList.add('hidden');
                showGameOver();
            });
            get('claim-reward-button').addEventListener('click', claimDailyReward);
            document.querySelectorAll('.buy-powerup-button').forEach(btn => btn.addEventListener('click', buyPowerUp));

            document.querySelectorAll('.powerup-button').forEach(btn => btn.addEventListener('click', activatePowerUp));

            gameBoard.addEventListener('click', handleBoardClick);
            ['mousedown', 'touchstart'].forEach(evt => gameBoard.addEventListener(evt, handleDragStart, {passive: false}));
            ['mousemove', 'touchmove'].forEach(evt => gameBoard.addEventListener(evt, handleDragMove, {passive: false}));
            ['mouseup', 'touchend', 'mouseleave'].forEach(evt => gameBoard.addEventListener(evt, handleDragEnd));
        }
        
        // --- 5. Player Progress & Data ---
        function savePlayerProgress() {
            localStorage.setItem('candyBlasterProgress', JSON.stringify(playerProgress));
        }
        function loadPlayerProgress() {
            const saved = localStorage.getItem('candyBlasterProgress');
            if (saved) {
                playerProgress = JSON.parse(saved);
                if (!playerProgress.powerUps) playerProgress.powerUps = { hammer: 3, bomb: 3, shuffle: 3 };
                if (!playerProgress.lastLogin) playerProgress.lastLogin = null;
            }
            updateCoinDisplay();
            updatePowerUpCounts();
        }
        function updateCoinDisplay() {
            get('player-coins-menu').textContent = `💰 ${playerProgress.coins}`;
            get('player-coins-game').textContent = `💰 ${playerProgress.coins}`;
        }
        function createFloatingCandies() {
            const container = get('floating-candies');
            container.innerHTML = '';
            for (let i = 0; i < 15; i++) {
                const candy = document.createElement('div');
                candy.className = 'floating-candy';
                candy.textContent = ALL_CANDIES[Math.floor(Math.random() * ALL_CANDIES.length)];
                candy.style.left = `${Math.random() * 100}%`;
                candy.style.animationDelay = `${Math.random() * 10}s`;
                container.appendChild(candy);
            }
        }

        // --- 6. New Features Logic (Daily Reward, Shop, Powerups, etc.) ---
        function checkDailyReward() {
            const today = new Date().toISOString().slice(0, 10);
            if (playerProgress.lastLogin !== today) {
                const coinsReward = 100 + Math.floor(Math.random() * 151);
                const powerUpReward = 1;
                get('daily-reward-text').innerHTML = `🎁 ${coinsReward} 💰 & 1 of each Power-Up!`;
                dailyRewardPopup.dataset.coins = coinsReward;
                dailyRewardPopup.dataset.powerups = powerUpReward;
                dailyRewardPopup.classList.remove('hidden');
            }
        }
        function claimDailyReward() {
            const coins = parseInt(dailyRewardPopup.dataset.coins);
            const powerups = parseInt(dailyRewardPopup.dataset.powerups);
            playerProgress.coins += coins;
            playerProgress.powerUps.hammer += powerups;
            playerProgress.powerUps.bomb += powerups;
            playerProgress.powerUps.shuffle += powerups;
            playerProgress.lastLogin = new Date().toISOString().slice(0, 10);
            savePlayerProgress();
            updateCoinDisplay();
            updatePowerUpCounts();
            dailyRewardPopup.classList.add('hidden');
        }

        function showShop() {
            shopPopup.classList.remove('hidden');
            document.querySelectorAll('.buy-powerup-button').forEach(btn => {
                btn.disabled = playerProgress.coins < parseInt(btn.dataset.price);
            });
        }
        function buyPowerUp(e) {
            const item = e.target.dataset.item;
            const amount = parseInt(e.target.dataset.amount);
            const price = parseInt(e.target.dataset.price);
            if (playerProgress.coins >= price) {
                playerProgress.coins -= price;
                playerProgress.powerUps[item] += amount;
                savePlayerProgress();
                updateCoinDisplay();
                updatePowerUpCounts();
                showShop(); 
            }
        }

        function updatePowerUpCounts() {
            for (const [powerup, count] of Object.entries(playerProgress.powerUps)) {
                get(`count-${powerup}`).textContent = count;
            }
        }

        function activatePowerUp(e) {
            if (isProcessing) return;
            const powerupType = e.currentTarget.dataset.powerup;
            if (playerProgress.powerUps[powerupType] <= 0) return;

            if (powerupType === 'shuffle') {
                useShufflePowerUp();
                return;
            }

            if (activePowerUp === powerupType) {
                activePowerUp = null;
                e.currentTarget.classList.remove('active');
                gameBoard.classList.remove('powerup-cursor');
            } else {
                activePowerUp = powerupType;
                document.querySelectorAll('.powerup-button').forEach(btn => btn.classList.remove('active'));
                e.currentTarget.classList.add('active');
                if(powerupType === 'hammer') gameBoard.classList.add('powerup-cursor');
            }
        }
        
        async function useShufflePowerUp() {
            if (isProcessing || playerProgress.powerUps.shuffle <= 0) return;
            isProcessing = true;
            playerProgress.powerUps.shuffle--;
            movesLeft--;
            updateHUD();
            updatePowerUpCounts();
            savePlayerProgress();
            await shuffleBoard(true);
            
            checkGameState();
            if (!winOrLosePopupIsVisible()) isProcessing = false;
        }

        async function handleBoardClick(e) {
            if (!activePowerUp || isProcessing) return;
            const cell = e.target.closest('.cell');
            if (!cell) return;
            
            isProcessing = true;
            const r = +cell.dataset.r;
            const c = +cell.dataset.c;

            playerProgress.powerUps[activePowerUp]--;
            movesLeft--;
            updateHUD();
            updatePowerUpCounts();
            savePlayerProgress();
            document.getElementById(`powerup-${activePowerUp}`).classList.remove('active');
            gameBoard.classList.remove('powerup-cursor');
            
            let toCrush = new Set();
            if (activePowerUp === 'hammer') {
                toCrush.add(`${r}-${c}`);
            } else if (activePowerUp === 'bomb') {
                animateBomb(r,c);
                for(let i = -1; i <= 1; i++) for(let j = -1; j <= 1; j++) {
                    if (r+i >= 0 && r+i < BOARD_SIZE && c+j >= 0 && c+j < BOARD_SIZE) {
                        toCrush.add(`${r+i}-${c+j}`);
                    }
                }
            }
            
            activePowerUp = null;
            
            const crushedSet = await crushAndActivate(toCrush);
            removeCrushedElements(crushedSet);
            await cascadeAndRefill();
            await processAllMatches();
            
            checkGameState();
            if (!winOrLosePopupIsVisible()) isProcessing = false;
        }

        function buyExtraMoves() {
            if (playerProgress.coins >= EXTRA_MOVES_COST) {
                playerProgress.coins -= EXTRA_MOVES_COST;
                movesLeft += 5;
                savePlayerProgress();
                updateHUD();
                updateCoinDisplay();
                extraMovesPopup.classList.add('hidden');
                isProcessing = false;
            } else {
                alert("Not enough coins!");
            }
        }
        
        // --- 7. Core Game Logic (Modified) ---
        function showMainMenu() {
            gameContainer.classList.add('hidden');
            levelSelectScreen.classList.add('hidden');
            mainMenuContainer.classList.remove('hidden');
            updateCoinDisplay();
        }

        function showLevelSelect() {
            mainMenuContainer.classList.add('hidden');
            levelSelectScreen.classList.remove('hidden');
            const levelGrid = get('level-grid');
            levelGrid.innerHTML = '';
            for (let i = 0; i < levels.length; i++) {
                const levelBtn = document.createElement('button');
                levelBtn.classList.add('level-button');
                levelBtn.dataset.level = i + 1;
                const levelNumSpan = document.createElement('span');
                levelNumSpan.textContent = i + 1;
                levelBtn.appendChild(levelNumSpan);
                if (i + 1 > playerProgress.unlockedLevel) {
                    levelBtn.disabled = true;
                    levelBtn.innerHTML = '&#x1F512;';
                } else {
                    levelBtn.onclick = () => showLevelGoal(i + 1);
                    const starsDiv = document.createElement('div');
                    starsDiv.className = 'stars';
                    starsDiv.innerHTML = '★'.repeat(playerProgress.levelStars[i+1] || 0) + '☆'.repeat(3 - (playerProgress.levelStars[i+1] || 0));
                    levelBtn.appendChild(starsDiv);
                }
                levelGrid.appendChild(levelBtn);
            }
        }
        
        function showLevelGoal(levelNum) {
            currentLevel = levelNum;
            const levelData = levels[currentLevel - 1];
            get('goal-level').textContent = `Level ${levelData.level}`;
            let objectiveText = '';
            
            switch(levelData.type) {
                case 'score': objectiveText = `Reach <strong>${levelData.target}</strong> points.`; break;
                case 'jelly': objectiveText = `Clear <strong>${levelData.jellyGoal}</strong> jellies.`; break;
                case 'stone': objectiveText = `Break <strong>${levelData.stoneGoal}</strong> stones.`; break;
                case 'ingredient': objectiveText = `Collect <strong>${levelData.ingredientGoal}</strong> ingredients 🍒.`; break;
                case 'collection':
                    objectiveText = `Collect: `;
                    for (const [candy, count] of Object.entries(levelData.collectGoal)) {
                        objectiveText += `<strong>${count} ${candy}</strong> `;
                    }
                    break;
            }
            get('goal-objective').innerHTML = `${objectiveText}<br>You have ${levelData.moves} moves.`;
            
            mainMenuContainer.classList.add('hidden');
            levelSelectScreen.classList.add('hidden');
            goalPopup.classList.remove('hidden');
        }

        function startGame(levelNum) {
            isProcessing = true;
            currentLevel = levelNum;
            const levelData = levels[currentLevel - 1];
            movesLeft = levelData.moves;
            score = 0;
            activePowerUp = null;
            document.querySelectorAll('.powerup-button').forEach(btn => btn.classList.remove('active'));
            gameBoard.classList.remove('powerup-cursor');
            
            switch(levelData.type) {
                case 'score': levelObjective = { type: 'score', progress: 0, target: levelData.target }; break;
                case 'jelly': levelObjective = { type: 'jelly', progress: 0, target: levelData.jellyGoal }; break;
                case 'stone': levelObjective = { type: 'stone', progress: 0, target: levelData.stoneGoal }; break;
                case 'ingredient': levelObjective = { type: 'ingredient', progress: 0, target: levelData.ingredientGoal, onBoard: 0, exitCols: levelData.exitCols }; break;
                case 'collection':
                    levelObjective = { type: 'collection', progress: {}, target: levelData.collectGoal, completed: {} };
                    for (const candy in levelData.collectGoal) { levelObjective.progress[candy] = 0; levelObjective.completed[candy] = false; }
                    break;
            }
            
            createBoard(levelData);
            updateHUD();
            updatePowerUpCounts();
            updateCoinDisplay();
            gameContainer.classList.remove('hidden');
            setTimeout(() => { isProcessing = false; }, 1000);
        }

        function updateHUD() {
            get('level-display').textContent = `Level: ${currentLevel}`;
            get('moves-display').textContent = `Moves: ${movesLeft}`;
            movesLeft <= 5 ? get('moves-display').classList.add('moves-warning') : get('moves-display').classList.remove('moves-warning');
            
            let html = '';
            switch(levelObjective.type) {
                case 'score': html = `Score: ${score} / ${levelObjective.target}`; break;
                case 'jelly': html = `Jelly: ${levelObjective.target - levelObjective.progress}`; break;
                case 'stone': html = `Stones: ${levelObjective.target - levelObjective.progress}`; break;
                case 'ingredient': html = `Ingredients: ${levelObjective.target - levelObjective.progress} 🍒`; break;
                case 'collection':
                    html = `Collect: `;
                    for (const [candy, target] of Object.entries(levelObjective.target)) {
                        const remaining = Math.max(0, target - (levelObjective.progress[candy] || 0));
                        html += `<span class="collection-item" data-candy="${candy}"><span class="collection-icon">${candy}</span> ${remaining}</span> `;
                    }
                    break;
            }
            get('objective-display').innerHTML = html;
        }

        function createBoard(levelData) {
            gameBoard.innerHTML = '';
            get('ingredient-exits').innerHTML = '';
            board = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                board[r] = [];
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.r = r; cell.dataset.c = c;
                    
                    if ((levelData.type === 'jelly' || levelData.type === 'stone') && levelData.layout && parseInt(levelData.layout[r][c]) > 0) {
                        cell.dataset[levelData.type] = levelData.layout[r][c];
                        cell.classList.add(`${levelData.type}-1`); // Always start with level 1 of blocker
                    }
                    
                    let candy;
                    do { candy = createRandomCandy(); } while (
                        (c >= 2 && candy.type === board[r][c - 1]?.type && candy.type === board[r][c - 2]?.type) ||
                        (r >= 2 && candy.type === board[r - 1][c]?.type && candy.type === board[r - 2][c]?.type)
                    );
                    
                    board[r][c] = candy;
                    cell.appendChild(candy.element);
                    gameBoard.appendChild(cell);
                }
            }
            if (levelData.type === 'ingredient') {
                const exits = get('ingredient-exits');
                for (let c=0; c<BOARD_SIZE; c++) {
                    const exit = document.createElement('div');
                    exit.className = 'exit-point';
                    if (levelObjective.exitCols.includes(c)) {
                        exit.classList.add('active');
                        exit.textContent = '▼';
                    }
                    exits.appendChild(exit);
                }
            }
        }
        
        function createRandomCandy(type = null, special = null) {
            const isIngredient = type === INGREDIENT;
            const candyType = isIngredient ? INGREDIENT : (type || CANDIES[Math.floor(Math.random() * CANDIES.length)]);
            const element = document.createElement('div');
            element.classList.add('candy');
            if (isIngredient) element.classList.add('ingredient');
            
            if (special) {
                element.classList.add(`candy-${special}`);
                element.textContent = special === 'color' ? RAINBOW_GEM : candyType;
            } else {
                element.textContent = candyType;
            }
            
            return { type: candyType, element, special, id: Math.random() };
        }

        async function handleSwap(cell1, cell2) {
            if (isProcessing) return;
            
            const r1 = +cell1.dataset.r, c1 = +cell1.dataset.c;
            const r2 = +cell2.dataset.r, c2 = +cell2.dataset.c;
            const candy1 = board[r1][c1];
            const candy2 = board[r2][c2];

            if (candy1?.type === INGREDIENT && candy2?.type === INGREDIENT) return;
            
            isProcessing = true;

            soundManager.play('swap');
            await animateSwap(cell1, cell2);
            [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
            
            let specialActivated = false;

            if (candy1?.special === 'color' || candy2?.special === 'color') {
                movesLeft--;
                updateHUD();
                if (candy1.special === 'color') await activateColorBomb(r1, c1, candy2.type);
                else await activateColorBomb(r2, c2, candy1.type);
                specialActivated = true;
            }

            const matches = findMatches();
            if (matches.size > 0) {
                if (!specialActivated) {
                    movesLeft--;
                    updateHUD();
                }
                await processAllMatches({r: r2, c: c2});
            } else if (!specialActivated) {
                await sleep(200);
                soundManager.play('swap');
                await animateSwap(cell1, cell2);
                [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
            }

            if(movesLeft > 0 && !winOrLosePopupIsVisible()) {
                while (!hasPossibleMoves()) {
                    await sleep(1000);
                    await shuffleBoard();
                }
            }
            
            checkGameState();
            if(!winOrLosePopupIsVisible()) isProcessing = false;
        }

        async function processAllMatches(swappedAt = null) {
            let matches;
            let chain = 0;
            const COMBO_TEXTS = ["Sweet!", "Tasty!", "Delicious!", "Divine!"];

            while ((matches = findMatches()).size > 0) {
                chain++;
                if (chain > 1) {
                    const text = COMBO_TEXTS[Math.min(chain - 2, COMBO_TEXTS.length - 1)];
                    showComboText(text);
                    soundManager.play('match');
                }
                score += matches.size * 10 * chain;
                
                const { toCrush, toCreate } = analyzeMatches(matches, swappedAt);
                const crushedSet = await crushAndActivate(toCrush);
                removeCrushedElements(crushedSet);
                await sleep(150);
                createSpecialCandies(toCreate);

                await cascadeAndRefill();
                swappedAt = null;
            }
        }

        function findMatches() {
            const matches = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const candy = board[r][c];
                    if (!candy || candy.special === 'color' || candy.type === INGREDIENT) continue;
                    
                    if (c < BOARD_SIZE - 2 && board[r][c+1]?.type === candy.type && board[r][c+2]?.type === candy.type) {
                        matches.add(`${r}-${c}`); matches.add(`${r}-${c+1}`); matches.add(`${r}-${c+2}`);
                    }
                    if (r < BOARD_SIZE - 2 && board[r+1][c]?.type === candy.type && board[r+2][c]?.type === candy.type) {
                        matches.add(`${r}-${c}`); matches.add(`${r+1}-${c}`); matches.add(`${r+2}-${c}`);
                    }
                }
            }
            return matches;
        }

        function analyzeMatches(matches, swappedAt) {
            const matchGroups = groupMatches(matches);
            const toCrush = new Set(matches);
            const toCreate = [];

            for (const group of matchGroups) {
                let createPos = swappedAt && group.cells.some(cell => cell.r === swappedAt.r && cell.c === swappedAt.c)
                    ? { ...swappedAt } : { r: group.cells[0].r, c: group.cells[0].c };
                
                if (group.is5Line) toCreate.push({ ...createPos, type: null, special: 'color' });
                else if (group.isT_or_L) toCreate.push({ ...createPos, type: group.type, special: 'bomb' });
                else if (group.length === 4) toCreate.push({ ...createPos, type: group.type, special: group.orientation === 'h' ? 'line-v' : 'line-h' });
            }
            return { toCrush, toCreate };
        }

        async function crushAndActivate(initialCrushSet) {
             soundManager.play('match');
             const fullCrushSet = new Set(initialCrushSet);
             const queue = [...initialCrushSet];
             const activatedSpecials = new Set();

             while(queue.length > 0) {
                const key = queue.shift();
                const [r,c] = key.split('-').map(Number);
                const candy = board[r]?.[c];

                if(candy?.special && !activatedSpecials.has(key)) {
                    activatedSpecials.add(key);
                    switch(candy.special) {
                        case 'line-h':
                            soundManager.play('line');
                            for (let i = 0; i < BOARD_SIZE; i++) { if(!fullCrushSet.has(`${r}-${i}`)) {fullCrushSet.add(`${r}-${i}`); queue.push(`${r}-${i}`)}}
                            break;
                        case 'line-v':
                            soundManager.play('line');
                            for (let i = 0; i < BOARD_SIZE; i++) { if(!fullCrushSet.has(`${i}-${c}`)) {fullCrushSet.add(`${i}-${c}`); queue.push(`${i}-${c}`)}}
                            break;
                        case 'bomb':
                            soundManager.play('bomb');
                            for(let i = -1; i <= 1; i++) for(let j = -1; j <= 1; j++) {
                                if (r+i >= 0 && r+i < BOARD_SIZE && c+j >= 0 && c+j < BOARD_SIZE) {
                                    const newKey = `${r+i}-${c+j}`;
                                    if(!fullCrushSet.has(newKey)) {fullCrushSet.add(newKey); queue.push(newKey)}
                                }
                            }
                            break;
                    }
                }
             }
             
            let animationPromises = [];
            for (const key of fullCrushSet) {
                const [r, c] = key.split('-').map(Number);
                const cell = getCell(r, c);
                const candy = board[r][c];
                if (!candy) continue;

                if (candy.element) {
                    candy.element.classList.add('crush-animation');
                    animationPromises.push(sleep(500));
                }
                
                if (cell.dataset.jelly && parseInt(cell.dataset.jelly) > 0) handleJelly(cell);
                if (cell.dataset.stone && parseInt(cell.dataset.stone) > 0) handleStone(cell);
                
                if (levelObjective.type === 'collection' && levelObjective.target[candy.type]) {
                    levelObjective.progress[candy.type] = (levelObjective.progress[candy.type] || 0) + 1;
                }
                if (levelObjective.type === 'ingredient' && candy.type === INGREDIENT) {
                    levelObjective.onBoard--;
                }
                
                if (activatedSpecials.has(key)) {
                    if (candy.special === 'bomb') animateBomb(r,c);
                    if (candy.special === 'line-h') animateLine(r,c, 'h');
                    if (candy.special === 'line-v') animateLine(r,c, 'v');
                }
                score += 10;
                board[r][c] = null;
            }
            updateHUD();
            await Promise.all(animationPromises);
            return fullCrushSet;
        }

        function removeCrushedElements(crushedSet) {
            crushedSet.forEach(key => {
                const [r, c] = key.split('-').map(Number);
                const cell = getCell(r,c);
                if(cell) cell.innerHTML = '';
            });
        }
        
        function createSpecialCandies(toCreate) {
             for (const {r, c, type, special} of toCreate) {
                 if (board[r][c] === null) {
                    soundManager.play('specialCreate');
                    const newCandy = createRandomCandy(type, special);
                    board[r][c] = newCandy;
                    getCell(r, c).appendChild(newCandy.element);
                 }
            }
        }
        
        async function activateColorBomb(r, c, targetType) {
            soundManager.play('line'); 
            const toCrush = new Set([`${r}-${c}`]);
            for(let i = 0; i < BOARD_SIZE; i++) {
                for(let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j]?.type === targetType) toCrush.add(`${i}-${j}`);
                }
            }
            const crushedSet = await crushAndActivate(toCrush);
            removeCrushedElements(crushedSet);
            await cascadeAndRefill();
            await processAllMatches();
        }

        function handleJelly(cell) {
             levelObjective.progress++;
             cell.classList.remove('jelly-1');
             cell.dataset.jelly = '0';
        }
        
        function handleStone(cell) {
            levelObjective.progress++;
            cell.classList.remove('stone-1');
            cell.dataset.stone = '0';
        }

        async function cascadeAndRefill() {
            if(levelObjective.type === 'ingredient') checkIngredientCollection();

            for (let c = 0; c < BOARD_SIZE; c++) {
                let writeRow = BOARD_SIZE - 1;
                for (let r = BOARD_SIZE - 1; r >= 0; r--) {
                    if (board[r][c]) {
                        if (r !== writeRow) {
                            board[writeRow][c] = board[r][c];
                            getCell(writeRow, c).appendChild(board[r][c].element);
                            board[r][c] = null;
                        }
                        writeRow--;
                    }
                }
            }
            await sleep(100);
            for (let c = 0; c < BOARD_SIZE; c++) {
                for (let r = BOARD_SIZE - 1; r >= 0; r--) {
                    if (board[r][c] === null) {
                        let newCandy;
                        if (levelObjective.type === 'ingredient' && levelObjective.onBoard + levelObjective.progress < levelObjective.target && r === 0 && Math.random() < 0.25) {
                            newCandy = createRandomCandy(INGREDIENT);
                            levelObjective.onBoard++;
                        } else {
                            newCandy = createRandomCandy();
                        }
                        board[r][c] = newCandy;
                        getCell(r,c).appendChild(newCandy.element);
                    }
                }
            }
            await sleep(200);
        }
        
        function checkIngredientCollection() {
            if (levelObjective.type !== 'ingredient') return;
            const lastRow = BOARD_SIZE - 1;
            for (const c of levelObjective.exitCols) {
                if (board[lastRow][c]?.type === INGREDIENT) {
                    levelObjective.progress++;
                    levelObjective.onBoard--;
                    board[lastRow][c].element.classList.add('crush-animation');
                    setTimeout(() => getCell(lastRow, c).innerHTML = '', 500);
                    board[lastRow][c] = null;
                    updateHUD();
                }
            }
        }

        function checkGameState() {
            // THE FIX IS HERE: The `if(isProcessing) return;` line was removed.
            let win = false;
            switch (levelObjective.type) {
                case 'score': win = score >= levelObjective.target; break;
                case 'jelly': win = levelObjective.progress >= levelObjective.target; break;
                case 'stone': win = levelObjective.progress >= levelObjective.target; break;
                case 'ingredient': win = levelObjective.progress >= levelObjective.target; break;
                case 'collection': 
                    win = Object.entries(levelObjective.target).every(([candy, target]) => (levelObjective.progress[candy] || 0) >= target); 
                    break;
            }

            if (win && !winOrLosePopupIsVisible()) {
                isProcessing = true;
                soundManager.play('win');
                get('final-score-win').textContent = `Your Score: ${score}`;
                const stars = score > (levelObjective.target || 5000) * 1.5 ? 3 : (score > (levelObjective.target || 3000) * 1.2 ? 2 : 1);
                const coinsWon = 10 * stars + Math.floor(movesLeft / 2);
                playerProgress.coins += coinsWon;
                get('coins-earned').textContent = `You earned ${coinsWon} 💰!`;
                
                const starRatingDiv = get('star-rating');
                starRatingDiv.innerHTML = '';
                for(let i=1; i<=3; i++) {
                    const starEl = document.createElement('span');
                    starEl.textContent = i <= stars ? '★' : '☆';
                    if (i <= stars) {
                        starEl.classList.add('star-animated');
                        starEl.style.animationDelay = `${i * 0.2}s`;
                    }
                    starRatingDiv.appendChild(starEl);
                }

                if (currentLevel === playerProgress.unlockedLevel) playerProgress.unlockedLevel++;
                playerProgress.levelStars[currentLevel] = Math.max(playerProgress.levelStars[currentLevel] || 0, stars);
                savePlayerProgress();
                levelCompletePopup.classList.remove('hidden');
            } else if (movesLeft <= 0 && !winOrLosePopupIsVisible()) {
                isProcessing = true;
                get('extra-moves-cost').textContent = `${EXTRA_MOVES_COST} 💰`;
                get('buy-moves-button').disabled = playerProgress.coins < EXTRA_MOVES_COST;
                extraMovesPopup.classList.remove('hidden');
            }
        }
        
        function showGameOver() {
            soundManager.play('lose');
            get('final-score-lose').textContent = `Your Score: ${score}`;
            gameOverPopup.classList.remove('hidden');
        }

        function hasPossibleMoves() {
            for(let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) if (board[r][c]?.special) return true;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if(board[r][c]?.type === INGREDIENT) continue;
                    if (c < BOARD_SIZE - 1 && board[r][c+1]?.type !== INGREDIENT) {
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                        if (findMatches().size > 0) { [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]]; return true; }
                        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
                    }
                    if (r < BOARD_SIZE - 1 && board[r+1][c]?.type !== INGREDIENT) {
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                        if (findMatches().size > 0) { [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]]; return true; }
                        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
                    }
                }
            }
            return false;
        }

        async function shuffleBoard(isPowerUp = false) {
            if (!isPowerUp) alert("No more possible moves! Shuffling the board...");
            const candies = document.querySelectorAll('.candy');
            candies.forEach(candy => {
                candy.style.transition = 'transform 0.5s ease-in, opacity 0.5s ease-in';
                candy.style.transform = `translate(${(Math.random() - 0.5) * 500}px, ${500}px) rotate(360deg)`;
                candy.style.opacity = '0';
            });
            await sleep(600);
            createBoard(levels[currentLevel - 1]);
            updateHUD();
            await sleep(500);
        }

        // --- 8. Helper & Animation Functions ---
        function getCell(r, c) { return gameBoard.querySelector(`[data-r='${r}'][data-c='${c}']`); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function areAdjacent(cell1, cell2) {
            const r1 = +cell1.dataset.r, c1 = +cell1.dataset.c;
            const r2 = +cell2.dataset.r, c2 = +cell2.dataset.c;
            return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
        }
        function winOrLosePopupIsVisible() {
            return !levelCompletePopup.classList.contains('hidden') || !gameOverPopup.classList.contains('hidden') || !extraMovesPopup.classList.contains('hidden');
        }
        
        async function animateSwap(cell1, cell2) {
            const candy1 = cell1.children[0], candy2 = cell2.children[0];
            const r1 = +cell1.dataset.r, c1 = +cell1.dataset.c;
            const r2 = +cell2.dataset.r, c2 = +cell2.dataset.c;
            if(candy1) candy1.style.transform = `translate(${(c2-c1)*100}%, ${(r2-r1)*100}%)`;
            if(candy2) candy2.style.transform = `translate(${(c1-c2)*100}%, ${(r1-r2)*100}%)`;
            await sleep(300);
            if(candy1) { cell2.appendChild(candy1); candy1.style.transform = ''; }
            if(candy2) { cell1.appendChild(candy2); candy2.style.transform = ''; }
        }
        
        function animateLine(r, c, dir) {
            const zap = document.createElement('div');
            zap.classList.add(dir === 'h' ? 'line-zap-h' : 'line-zap-v');
            getCell(r, c).appendChild(zap);
            setTimeout(() => zap.remove(), 400);
        }

        function animateBomb(r, c) {
            const explosion = document.createElement('div');
            explosion.classList.add('bomb-explosion');
            explosion.style.top = `calc(var(--cell-size) * ${r + 0.5})`;
            explosion.style.left = `calc(var(--cell-size) * ${c + 0.5})`;
            gameBoard.appendChild(explosion);
            setTimeout(() => explosion.remove(), 400);
        }

        function showComboText(text) {
            const comboEl = document.createElement('div');
            comboEl.className = 'combo-text';
            comboEl.textContent = text;
            gameBoard.appendChild(comboEl);
            setTimeout(() => comboEl.remove(), 1500);
        }
        
        function groupMatches(matchSet) {
            const groups = [];
            const visited = new Set();
            for (const cellKey of matchSet) {
                if (visited.has(cellKey)) continue;
                const currentGroup = new Set();
                const queue = [cellKey];
                visited.add(cellKey);
                const [startR, startC] = cellKey.split('-').map(Number);
                const type = board[startR][startC]?.type;
                if (!type) continue;
                while (queue.length > 0) {
                    const currentKey = queue.shift();
                    currentGroup.add(currentKey);
                    const [r, c] = currentKey.split('-').map(Number);
                    [[r, c + 1], [r, c - 1], [r + 1, c], [r - 1, c]].forEach(([nr, nc]) => {
                        const neighborKey = `${nr}-${nc}`;
                        if (matchSet.has(neighborKey) && !visited.has(neighborKey) && board[nr]?.[nc]?.type === type) {
                            visited.add(neighborKey);
                            queue.push(neighborKey);
                        }
                    });
                }
                if (currentGroup.size > 0) {
                    const cells = [...currentGroup].map(k => ({ r: +k.split('-')[0], c: +k.split('-')[1] }));
                    const rows = cells.map(cell => cell.r);
                    const cols = cells.map(cell => cell.c);
                    const width = Math.max(...cols) - Math.min(...cols) + 1;
                    const height = Math.max(...rows) - Math.min(...rows) + 1;
                    const isT_or_L = width >= 3 && height >= 3;
                    const is5Line = (width === 5 && height === 1) || (width === 1 && height === 5);
                    const orientation = width > height ? 'h' : 'v';
                    const length = currentGroup.size;
                    if (length >= 4 || isT_or_L) groups.push({ type, length, isT_or_L, is5Line, orientation, cells });
                }
            }
            return groups;
        }

        // --- 9. Swipe Control Handlers ---
        function handleDragStart(e) {
            if (isProcessing || activePowerUp) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            dragStartCell = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.cell');
        }

        function handleDragMove(e) {
            if (!dragStartCell || isProcessing || activePowerUp) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const dragOverCell = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.cell');

            if (dragOverCell && dragOverCell !== dragStartCell && areAdjacent(dragStartCell, dragOverCell)) {
                handleSwap(dragStartCell, dragOverCell);
                dragStartCell = null;
            }
        }

        function handleDragEnd(e) {
            dragStartCell = null;
        }

        init();
    });
    </script>
</body>
</html>